diff --git a/files/entry.js b/files/entry.js
index 5f022e5096b97e945a1327e62cd64dbff52086a6..cdb0b21c1fa5ad891a852705397f35a6efc0a630 100644
--- a/files/entry.js
+++ b/files/entry.js
@@ -1,7 +1,12 @@
 import { Server } from 'SERVER';
 import { manifest, prerendered, base_path } from 'MANIFEST';
+import handlers from 'HANDLERS';
 import { getAssetFromKV, mapRequestToAsset } from '@cloudflare/kv-asset-handler';
 import static_asset_manifest_json from '__STATIC_CONTENT_MANIFEST';
+import { WorkerEntrypoint } from 'cloudflare:workers';
+
+export * from 'HANDLERS';
+
 const static_asset_manifest = JSON.parse(static_asset_manifest_json);
 
 const server = new Server(manifest);
@@ -11,100 +16,112 @@ const app_path = `/${manifest.appPath}`;
 const immutable = `${app_path}/immutable/`;
 const version_file = `${app_path}/version.json`;
 
-export default {
-	/**
-	 * @param {Request} req
-	 * @param {any} env
-	 * @param {any} context
-	 */
-	async fetch(req, env, context) {
-		await server.init({ env });
-
-		const url = new URL(req.url);
-
-		// static assets
-		if (url.pathname.startsWith(app_path)) {
-			/** @type {Response} */
-			const res = await get_asset_from_kv(req, env, context);
-			if (is_error(res.status)) return res;
-
-			const cache_control = url.pathname.startsWith(immutable)
-				? 'public, immutable, max-age=31536000'
-				: 'no-cache';
-
-			return new Response(res.body, {
-				headers: {
-					// include original headers, minus cache-control which
-					// is overridden, and etag which is no longer useful
-					'cache-control': cache_control,
-					'content-type': res.headers.get('content-type'),
-					'x-robots-tag': 'noindex'
-				}
-			});
-		}
+/**
+ * @param {Request} req
+ * @param {any} env
+ * @param {any} context
+ */
+async function fetch(req, env, context) {
+	await server.init({ env });
+
+	const url = new URL(req.url);
+
+	// static assets
+	if (url.pathname.startsWith(app_path)) {
+		/** @type {Response} */
+		const res = await get_asset_from_kv(req, env, context);
+		if (is_error(res.status)) return res;
+
+		const cache_control = url.pathname.startsWith(immutable)
+			? 'public, immutable, max-age=31536000'
+			: 'no-cache';
+
+		return new Response(res.body, {
+			headers: {
+				// include original headers, minus cache-control which
+				// is overridden, and etag which is no longer useful
+				'cache-control': cache_control,
+				'content-type': res.headers.get('content-type'),
+				'x-robots-tag': 'noindex'
+			}
+		});
+	}
 
-		let { pathname, search } = url;
-		try {
-			pathname = decodeURIComponent(pathname);
-		} catch {
-			// ignore invalid URI
-		}
+	let { pathname, search } = url;
+	try {
+		pathname = decodeURIComponent(pathname);
+	} catch {
+		// ignore invalid URI
+	}
 
-		const stripped_pathname = pathname.replace(/\/$/, '');
-
-		// prerendered pages and /static files
-		let is_static_asset = false;
-		const filename = stripped_pathname.slice(base_path.length + 1);
-		if (filename) {
-			is_static_asset =
-				manifest.assets.has(filename) ||
-				manifest.assets.has(filename + '/index.html') ||
-				filename in manifest._.server_assets ||
-				filename + '/index.html' in manifest._.server_assets;
-		}
+	const stripped_pathname = pathname.replace(/\/$/, '');
+
+	// prerendered pages and /static files
+	let is_static_asset = false;
+	const filename = stripped_pathname.slice(base_path.length + 1);
+	if (filename) {
+		is_static_asset =
+			manifest.assets.has(filename) ||
+			manifest.assets.has(filename + '/index.html') ||
+			filename in manifest._.server_assets ||
+			filename + '/index.html' in manifest._.server_assets;
+	}
 
-		let location = pathname.at(-1) === '/' ? stripped_pathname : pathname + '/';
-
-		if (
-			is_static_asset ||
-			prerendered.has(pathname) ||
-			pathname === version_file ||
-			pathname.startsWith(immutable)
-		) {
-			return get_asset_from_kv(req, env, context, (request, options) => {
-				if (prerendered.has(pathname)) {
-					url.pathname = '/' + prerendered.get(pathname).file;
-					return new Request(url.toString(), request);
-				}
-
-				return mapRequestToAsset(request, options);
-			});
-		} else if (location && prerendered.has(location)) {
-			if (search) location += search;
-			return new Response('', {
-				status: 308,
-				headers: {
-					location
-				}
-			});
-		}
+	let location = pathname.at(-1) === '/' ? stripped_pathname : pathname + '/';
+
+	if (
+		is_static_asset ||
+		prerendered.has(pathname) ||
+		pathname === version_file ||
+		pathname.startsWith(immutable)
+	) {
+		return get_asset_from_kv(req, env, context, (request, options) => {
+			if (prerendered.has(pathname)) {
+				url.pathname = '/' + prerendered.get(pathname).file;
+				return new Request(url.toString(), request);
+			}
 
-		// dynamically-generated pages
-		return await server.respond(req, {
-			platform: {
-				env,
-				context,
-				// @ts-expect-error lib.dom is interfering with workers-types
-				caches,
-				// @ts-expect-error req is actually a Cloudflare request not a standard request
-				cf: req.cf
-			},
-			getClientAddress() {
-				return req.headers.get('cf-connecting-ip');
+			return mapRequestToAsset(request, options);
+		});
+	} else if (location && prerendered.has(location)) {
+		if (search) location += search;
+		return new Response('', {
+			status: 308,
+			headers: {
+				location
 			}
 		});
 	}
-};
+
+	// dynamically-generated pages
+	return await server.respond(req, {
+		platform: {
+			env,
+			context,
+			// @ts-expect-error lib.dom is interfering with workers-types
+			caches,
+			// @ts-expect-error req is actually a Cloudflare request not a standard request
+			cf: req.cf
+		},
+		getClientAddress() {
+			return req.headers.get('cf-connecting-ip');
+		}
+	});
+}
+
+export default 'prototype' in handlers && handlers.prototype instanceof WorkerEntrypoint
+	? Object.defineProperty(handlers.prototype, 'fetch', {
+		value: fetch,
+		writable: true,
+		enumerable: false,
+		configurable: true
+	})
+	: Object.defineProperty(handlers, 'fetch', {
+		value: fetch,
+		writable: true,
+		enumerable: true,
+		configurable: true
+	});
 
 /**
  * @param {Request} req
diff --git a/index.d.ts b/index.d.ts
index b76003735910c20b7d46246d38c08c82e17f6a69..bc474a156ab19983bc528c52b0fe17ee1a82362b 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -6,6 +6,10 @@ export default function plugin(options?: AdapterOptions): Adapter;
 
 export interface AdapterOptions {
 	config?: string;
+	/**
+	 * Path to a file with additional {@link https://developers.cloudflare.com/workers/runtime-apis/handlers/ | handlers} and (optionally) {@link https://developers.cloudflare.com/durable-objects/ | Durable Objects} to be exported from the file the adapter generates.
+	 */
+	handlers?: string;
 	/**
 	 * Config object passed to {@link https://developers.cloudflare.com/workers/wrangler/api/#getplatformproxy | getPlatformProxy}
 	 * during development and preview.
diff --git a/index.js b/index.js
index 02f8c7caff86fb3f9ce84b6fd9b0a64c1a40be57..5e36cb97208d38ec0211978211cc3182c6091bc8 100644
--- a/index.js
+++ b/index.js
@@ -1,6 +1,7 @@
 import { existsSync, readFileSync, writeFileSync } from 'node:fs';
-import { posix, dirname } from 'node:path';
+import { posix, dirname, resolve } from 'node:path';
 import { execSync } from 'node:child_process';
+import { cwd } from 'node:process';
 import esbuild from 'esbuild';
 import toml from '@iarna/toml';
 import { fileURLToPath } from 'node:url';
@@ -32,7 +33,7 @@ const compatible_node_modules = [
 ];
 
 /** @type {import('./index.js').default} */
-export default function ({ config = 'wrangler.toml', platformProxy = {} } = {}) {
+export default function ({ config = 'wrangler.toml', platformProxy = {}, handlers } = {}) {
 	return {
 		name: '@sveltejs/adapter-cloudflare-workers',
 
@@ -58,7 +59,8 @@ export default function ({ config = 'wrangler.toml', platformProxy = {} } = {})
 			builder.copy(`${files}/entry.js`, `${tmp}/entry.js`, {
 				replace: {
 					SERVER: `${relativePath}/index.js`,
-					MANIFEST: './manifest.js'
+					MANIFEST: './manifest.js',
+					HANDLERS: './_handlers.js'
 				}
 			});
 
@@ -74,10 +76,24 @@ export default function ({ config = 'wrangler.toml', platformProxy = {} } = {})
 			writeFileSync(
 				`${tmp}/manifest.js`,
 				`export const manifest = ${builder.generateManifest({ relativePath })};\n\n` +
-					`export const prerendered = new Map(${JSON.stringify(prerendered_entries)});\n\n` +
-					`export const base_path = ${JSON.stringify(builder.config.kit.paths.base)};\n`
+				`export const prerendered = new Map(${JSON.stringify(prerendered_entries)});\n\n` +
+				`export const base_path = ${JSON.stringify(builder.config.kit.paths.base)};\n`
 			);
 
+			if (handlers) {
+				// TODO: find a more robust way to resolve files relative to svelte.config.js
+				const handlers_file = resolve(cwd(), handlers);
+				writeFileSync(
+					`${tmp}/_handlers.js`,
+					`import handlers from "${handlers_file}";\n\n` +
+					`export * from "${handlers_file}";\n\n` +
+					'export default handlers;'
+				);
+			} else {
+				// The handlers file must export a plain object as its default export.
+				writeFileSync(`${tmp}/_handlers.js`, 'export default {};');
+			}
+
 			const external = ['__STATIC_CONTENT_MANIFEST', 'cloudflare:*'];
 			if (compatibility_flags && compatibility_flags.includes('nodejs_compat')) {
 				external.push(...compatible_node_modules.map((id) => `node:${id}`));
@@ -137,8 +153,7 @@ export default function ({ config = 'wrangler.toml', platformProxy = {} } = {})
 				console.error(formatted.join('\n'));
 
 				throw new Error(
-					`Bundling with esbuild failed with ${error.errors.length} ${
-						error.errors.length === 1 ? 'error' : 'errors'
+					`Bundling with esbuild failed with ${error.errors.length} ${error.errors.length === 1 ? 'error' : 'errors'
 					}`
 				);
 			}
@@ -149,29 +164,35 @@ export default function ({ config = 'wrangler.toml', platformProxy = {} } = {})
 			builder.writePrerendered(bucket_dir);
 		},
 
-		async emulate() {
-			const proxy = await getPlatformProxy(platformProxy);
-			const platform = /** @type {App.Platform} */ ({
-				env: proxy.env,
-				context: proxy.ctx,
-				caches: proxy.caches,
-				cf: proxy.cf
-			});
+		emulate() {
+			// we want to invoke `getPlatformProxy` only once, but await it only when it is accessed.
+			// If we would await it here, it would hang indefinitely because the platform proxy only resolves once a request happens
+			const getting_platform = (async () => {
+				const proxy = await getPlatformProxy(platformProxy);
+				const platform = /** @type {App.Platform} */ ({
+					env: proxy.env,
+					context: proxy.ctx,
+					caches: proxy.caches,
+					cf: proxy.cf
+				});
 
-			/** @type {Record<string, any>} */
-			const env = {};
-			const prerender_platform = /** @type {App.Platform} */ (/** @type {unknown} */ ({ env }));
+				/** @type {Record<string, any>} */
+				const env = {};
+				const prerender_platform = /** @type {App.Platform} */ (/** @type {unknown} */ ({ env }));
 
-			for (const key in proxy.env) {
-				Object.defineProperty(env, key, {
-					get: () => {
-						throw new Error(`Cannot access platform.env.${key} in a prerenderable route`);
-					}
-				});
-			}
+				for (const key in proxy.env) {
+					Object.defineProperty(env, key, {
+						get: () => {
+							throw new Error(`Cannot access platform.env.${key} in a prerenderable route`);
+						}
+					});
+				}
+				return { platform, prerender_platform };
+			})();
 
 			return {
-				platform: ({ prerender }) => {
+				platform: async ({ prerender }) => {
+					const { platform, prerender_platform } = await getting_platform;
 					return prerender ? prerender_platform : platform;
 				}
 			};
